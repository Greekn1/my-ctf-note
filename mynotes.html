<!DOCTYPE html>
<html>
<head>
    <title>我的网络安全学习笔记</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 30px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 30px;
        }
        .note-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        h2 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        pre {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        .back-link {
            display: block;
            text-align: center;
            margin-top: 30px;
            color: #3498db;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>📚 我的网络安全学习笔记</h1>
        <p>CTF与网络相关知识总结</p>
    </div>

    <div class="note-section">
        <h2>🔍 CTFshow Web题</h2>
        <pre>web1：简单的base64解码，F12查看源代码，觉得有可能是base64，找了个在线解码网站解决了问题

web2：最简单的sql注入，因为啥都不懂首先先看答案，找了个写得很详细的，然后把他的话复制粘贴下来一句一句问ai
字段：列
字段名：基本等于列名
注入点：没做好数据和代码的区分，可以进行注入的交互处
-- 和#：注释符，作用是把后面的内容统统变成注释，让注入语句能无干扰运行
' or 1=1#或者' or 1=1 -- ：一种万能钥匙，用来检测是否存在注入
select：选择数据库进行查询
where：给select查询的数据加上筛选条件
union：合并查询结果，所以union后面可以跟查询语句
information_schema.tables(不知道为什么下横线打不出来)：存储着其他数据库，表，列，权限的信息
information_schema.columns：存储着数据库的字段名
table_schema：数据库名
table_name：表名
column_name：字段名
limit offset,count：从第offset条记录开始返回count条记录
（）：作用同数学里的（），即提高括号中内容的运算优先级
database()：一个内置函数，用于查看当前使用的数据库名
步骤：
1.f12查看源代码起手，答案说觉得没异常所以考虑sql注入，我经验不足所以就跟着答案走
2.万能钥匙测试是否存在注入，输入' or 1=1#显示登陆成功，存在注入
3.再输' or 1=0#，页面无反应，判断存在注入点（没搞懂）
4.尝试union注入，输入' union select 1,2,3#，返回"欢迎你，2"，故原始查询返回的列数是三列，第二列可以插入sql语句
5.注入' union select 1,database(),3#，返回web2，成功获取数据库名
6.接下来获取表名，输入' union select 1,(select table_name from information_schema.tables where table_schema='web2' limit 0,1),3#，返回了flag，limit后改成 1,1和 2,1分别返回了user和啥也没有
*group_concat(表名)：一次性查看所有表名
7.先盲猜flag在flag里面，输入' union selecr 1,(select column_name from information schema.column where table_schema='web2' and table_name=flag limit 0,1),3#用于获取flag表的第一个字段，返回"欢迎你，flag"，说明flag表里有flag字段
8.直接查询flag表的flag字段里的数据，输入' union select 1,(select flag from flag),3#，成功获取flag
总结：好jb难，这种最简单的sql注入对零基础的人而言还是太不友好了，我一开始还想着快速学习了解一下mysql的重要语法以及其他关键点，理所当然的做不到，于是我老老实实地找了个写得很详细的wp，然后把他的话复制粘贴下来一句一句问ai，如果没有这位的wp和好用的ai我搞明白答案每一步在做什么以及为什么要这么做的时间估计得翻倍

web3：文件包含漏洞和php伪协议
原理类似sql注入，都是通过某些方法让服务器端执行用户注入的代码来获取数据
php：一种用于web开发的后端语言，可以无视元素插入html执行
伪协议：这个概念卡了我好久，后来我才理解伪协议确实就如字面意义所言，不是协议。。。总而言之伪协议是面向本地的指令，与网络和通信都没有关系
?url=php://input：一种伪协议，作用似乎是要求服务器端读取请求体中未经编译或者处理过的内容
①<?php system('ls');?>和②<?php system(文件名);?>：关键代码，作用分别是让服务器端列出当前目录下文件和文件夹，以及查看目标文件的内容
解法一：个人感觉最简单的方法，用burp抓包之后改完url参数并在请求体里分别输入①和②执行

解法二：修改自己的user_agent为一句话木马，然后利用文件包含漏洞，通过执行这句payload：?url=/var/log/nginx/access.log来访问文件日志，php解释器读取到木马的时候会把它作为程序运行，使得木马被激活，之后使用蚁剑以post方式提交命令就能获得webshell权限了

解法三：本质还是木马，只不过是利用data://伪协议直接把木马嵌到url里让服务器端执行，payload是?url=data://text/plain;base64,PD9waHAgZXZhbCgkX1BPU1RbMV0pOz8%2b，之后流程和二一样，用蚁剑连接获取权限即可

解法四：我觉得是非常狡猾而精妙的解法

payload是?url=php://filter/read=convert.base64-decode/resource=data://text/plain;base64,UEQ5d2FIQWdRR1YyWVd3b0pGOVFUMU5VV3pGZEtUcy9QZz09

前半段的php://filter/read=convert.base64-decode/resouce=功能是木马到达客户端时对其进行进行第一次解码，data://text/plain;base64,UEQ5d2FIQWdjR2h3YVc1bWJ5Z3BPejgr则是用来传递木马的

UEQ5d2FIQWdRR1YyWVd3b0pGOVFUMU5VV3pGZEtUcy9QZz09是<?php @eval($_POST[1]);?>这个一句话木马经过两次base64编码之后的结果
而PD9waHAgQGV2YWwoJF9QT1NUWycxJ10pOz8+是木马的一次编码状态
（@用于抑制表达式可能产生的错误信息，增强隐蔽性；eval函数让php解释器把字符串参数作为代码执行；$_POST作为超全局变量用于接收蚁剑通过post请求的请求体传递的指令；[1]是指令的参数名）

关于php://filter：是一个php特有的协议，作用是过滤器，用于对读取或者写入的数据流进行处理，以下是这个payload中使用的参数
resource=<要过滤的数据流>，用于指定要筛选过滤的数据流
read=<读链的筛选列表>
而convert.base64-decode是一种转换过滤器，似乎是用于绕过过滤了某些字符的题目的


include函数（或者require）执行payload时convert.base64-decode会先对木马进行一次解码，木马从二次编码状态变为一次编码状态之后，php解释器由于include函数（或require函数）的缘故会把一次编码的木马作为代码执行，由于原始木马是可被执行的php代码，这里只是经过了一次base64编码，因此php解释器可以正常识别并正常运行它（php语法解析器的功劳），执行之后木马被激活，此时用蚁剑连接，之后步骤同二

web4：日志包含漏洞，web3的解法二

web5：MD5弱比较漏洞
ctype_alpha：php内置的检测字符串是否是纯字母的函数
is_numeric：php中检查变量是否为数值的函数，可以识别科学计数法，也可以识别含有“，”的数字组合
题目给了一个html文件，要求v1为纯字母字符串，v2为数字字符串，当二者通过md5算法得到的哈希值松散相等的时候返回flag
由于题目采用松散相等（弱比较，表现为==），故若md5产生的哈希值均为0e开头时根据php的算法二者的值均为0，这是解题的关键
知道了它的要求的话这道题很简单，网上找找符合条件的字符串就行了

#关于松散相等：
1.数字与字符串比较​：当字符串与数字比较时，PHP 会尝试将字符串转换为数字，然后再进行比较，如"123" == 123结果为 true
更特别的是，如果一个字符串不是以数字开头，它会被转换为 0，这使得 "abc" == 0的结果也为 true

​2.布尔值与其他类型比较​：布尔值 true和 false在比较时也会被转换。false在松散比较中与数字 0、空字符串 ""、空数组 []以及null都被认为是相等的（结果均为 true）
而 true与非空的非零值（如 "php"）比较也为 true

3.特殊情况​：null在松散比较中，与false和空字符串""和undefined是相等的，但与0的比较结果在不同PHP版本中可能存在差异，需要特别注意
NaN是一个特殊的数值，表示“不是一个数字”，有趣的是，NaN与任何值（包括它自己）进行松散相等比较结果都是 false，这是因为 NaN本身就代表一个不确定或非法的数值

web6：sql注入，尝试了' or 1=1#发现返回sql inject error，想了半天不知道为什么，毕竟没碰见过这种情况，看了wp发现是过滤了空格，除了过滤了空格输入，其他和web2一模一样，关键在于判断它过滤了什么字符

web7：原来地址栏也可以执行sql注入！之前我一直以为只有登录界面这种东西可以sql注入
原理还是和2一样，只是交互点从登陆界面变成了地址栏，同时过滤了单引号和空格字符</pre>
    </div>

    <div class="note-section">
        <h2>🌐 计算机网络体系结构摘要（基于计算机网络原理与实践第一版，书很老但比较易懂）</h2>
        <pre>章1 绪论

各种英文缩写名词
1.IMP：接口信息处理机
2.NAP：网络接入点
3.ISP：网络服务提供商

分组交换技术：又称电路交换   面向连接性：拨号建立连接后可通信
                                            通信资源独占性：建立后用户线被连接独占

具体技术实现有两点：数据报--无需建立连接即可通信--分组独立转发----每个分组中均有完整地址--分组乱序，接收方需排列
                               虚电路--连接通信--分组按序转发----易受传递过程中的硬件故障影响

章2 计算机网络体系结构

网络协议三要素：语法--语义--时序

协议分层：就结果看是同层次协议对等传递，就过程看是逐级下降再逐级上升（物理链路为最底层）
                每降一层就会在原始数据的基础上多封装一次，每升一层就会在原包的基础上去掉一层封装、

网络体系结构模型
osi七层：应用--表示--会话--运输--网络--数据链路--物理
TCP/IP四(五)层：应用--运输--网络--(数据链路)--物理

各层数据单位
1.应用层--报文/数据
2.运输层--段/数据报
3.网络层--分组/包/数据报
4.数据链路层--帧
5物理层--比特流

章3 应用层

应用层的基本模型是客户-服务器模型，先发起通信的应用进程是客户，等待通信的应用进程是服务器

Web:80
FTP:21
DNS:53
SMTP:25
POP3:110
Telnet:23

一，web相关
URL:统一资源定位符
格式：访问方式://主机:端口/路径
主机可以用域名或者IP表示

www由三部分组成：HTML语言，http协议，web浏览器，web服务器

HTML（超文本标记语言）写成的文档就是网页（超文本文档）
网页内容储存在服务器中，收到请求（地址栏键入URL或用户单击链接时）后在本地硬盘中找到对应网页返回给浏览器，浏览器根据网页中的标记去解释内容显示给用户，整个过程遵守http协议（超文本传输协议）

http协议：默认80端口，用于web服务，依赖于tcp协议支持，是无状态协议
http报文：有两种，请求和应答，B/S架构通过传递这两种报文来实现http协议

请求报文
请求行：方法，URL，协议版本号
首部行：首部，值。两者间用冒号间隔
①Accept：可接受的文档类型
②Accept-Language：优先接受的语言类型
③Accept-Encoding：能理解的编码方式
④User-Agent：浏览器类型
⑤Host：所访问的主机
⑥Connection：告知服务器做完应答后是否继续保持连接

应答报文
状态行：协议版本号，状态码，状态码说明
首部行：同请求报文
①Connection
②Date
③Last-Modified
④Content-Length
⑤Content-Type

请求行的方法字段：GET,POST,HEAD,PUT,DELETE

web代理：代理服务器起中转站的作用，其中会缓存一些目标服务器的网站
条件GET：代理服务器用于检测缓存网站是否是最新的机制

Cookie：一种web网站用于记录用户行为的技术，具体实现是在用户本地硬盘处存储一些<名字，值>对，下次访问相同网站时GET请求首部中会加入这条信息，用于让服务器取出对应用户的数据

二，文件传输相关

多点下载：多线程下载，同时下载一个文件的不同部分以提高带宽利用效率，从而加快下载速度，原理是发送多个下载请求，每个请求中加入range，来同时下载多个部分
断点续传：从上次中断的地方开始下载，原理是暂停下载时记录下载进度，下次重启时按进度设置range值

FTP协议（文件传输协议）：默认占用20，21端口，同样依赖tcp协议支持，不同于http的bs，采用cs架构，以交互式命令方式运行，是有状态协议

21端口是控制连接，20端口是数据连接（占用的都是服务器端口，客户端口是随机分配的）

控制连接用于传输用户命令，数据连接用于传输文件数据

控制连接是持久的，数据连接是暂时的

主动模式和被动模式：主动和被动都是相对服务器而言的，主动就是服务器主动向客户发起数据连接，被动则是客户先通过控制连接发送PASV命令，告知服务器使用被动模式，服务器收到命令后选择随机端口号，并将端口号通过port命令从控制连接传递给客户，客户接受到之后再发起数据连接

FTP命令：基本是c向s
①USER：表身份，参数用户名
②PASS：传递口令，参数口令，通常与USER连用
③LIST：列出当前目录下的文件与子目录
④CWD：改变当前目录，参数文件路径
⑤CDUP：回到上级目录
⑥PWD：显示当前目录
⑦RETR：下载文件，参数下载文件名
⑧STOR：上传文件，参数上传文件名
⑨DELE：删除文件，参数删除文件名
⑩MKD：新建目录，参数新建目录名
11.RMD：删除目录，参数删除文件名
12.PORT：告知端口，分主被动
13.PASV：通知s采取被动
14.HELP：帮助
15.QUIT：退出

FTP应答：s向c
状态码+文本字符串（解释状态码）

三，电子邮件相关

电子邮件：两种方式，客户端软件和web邮件
关键协议：简单邮件传输协议（SMTP协议），因特网消息访问协议（IMAP协议），第三版邮局协议（POP3），如果使用web邮件，还会涉及到web相关协议，如http

电子邮件报文格式
首部
（中间用空行隔开）
报文主体

常用首部：
①From：发送方
②To：接收方
③Cc：抄送
④Bcc：暗送
⑤Subject：邮件主题
⑥Date：邮件发送时间

SMTP协议：cs架构，25端口侦听，依赖tcp

SMTP命令：
①HELO，EHLO：表身份，有参数
②MAIL：开始邮件发送过程，命令格式为MAIL FROM：发信者地址
③RCPT：表邮件接收者
④DATA：告知s下面是内容，s收到后要回应354
⑤RSET：终止当前邮件传输活动，s会丢弃发送者，接收者和邮件内容，但是需要保持和客户端的连接，会话恢复到初始状态
⑥VRFY：验证s上是否有某用户存在，参数用户名
⑦QUIT：结束会话，关闭连接

SMTP命令：
状态码+文本字符串（解释状态码）+回车符+换行符

SMTP协议扩展：诞生于想要传输非ascll码数据的需求，以MIME为例
MIME描述了文件类型，给出非ascll码和ascll码之间的转换办法（主要用quoted-printable和base-64两种编码，前者用于含有少量非ascll码字符的数据，如汉字，多用于邮件正文编码；后者适合任意的二进制文件，多用于邮件附件编码）

POP3协议（获取邮件的协议）：依赖TCP，在110端口监听，cs间以命令/应答的方式工作

POP3会下载邮件到本地，同时删除服务器上的对应邮件

POP3命令
USER,PASS基本可以类比FTP
LIST列出邮件基本信息（大小，以字节为单位），参数邮件，不带参数遍历
STAT列出邮件统计信息，即总个数与大小
RETP获取邮件，参数邮件编号
DELE删除邮件，参数同上，不是立即执行而是在客户端退出之后执行
RSET撤销删除标记
QUIT退出
TOP需要两参数，用于获得邮件首部信息与正文前两行信息

POP3应答
只有两种，肯定（+OK）和否定（-ERR）

IMAP协议：支持离线在线管理邮件，比POP3普适

DNS协议：提供从域名到IP地址的映射

域名由若干部分组成：
…….三级域名.二级域名.顶级域名

顶级域名：cn中国，jp日本，uk英国，com公司，net网络机构，org组织机构等等等等

域名转换为IP的过程叫域名解析，通过域名服务器执行域名解析服务程序来进行，域名服务器在世界各地大量分布，每台服务器提供部分域名的解析，它们共同构成一个分布式的数据库系统

根状分布，顶层是根域名服务器，往下依次是顶级，二级，三级等，日常使用的是本地域名服务器，通常由ISP提供，用户需要在计算机中设置本地域名服务器的地址

DHCP协议（动态主机配置协议）依赖UDP协议，其他详见网络五层结构模型笔记，具体报文格式暂不记录

DHCP中继代理，字面意思，中继

</pre>
    </div>

    <div class="note-section">
        <h2>网络五层结构与网络历史知识点总结（基于B站视频记录，感谢那些愿意花时间做科普的大佬们，给我的学习过程省去了不少理解上的痛点）</h2>
        <pre>计算机网络结构简明解释：
两台机子之间可以直接用数据线传输数据

多机之间交流需要标识与转发

多台间用数据线传输，拉线的数量太多，很麻烦，于是HUB/集线器出现了

HUB连接所有机子，接受所有机子的数据包并转发给所有机子，因此无法定向传输数据，而且如果有多机同时发数据包的情况，会出现数据杂糅的问题

针对数据杂糅，解决方案是CSMA/CD协议，它会在发数据包之前侦测线路上有没有正在传输的数据，从而避免数据杂糅

这是最初设计出来的计算机网络，由于同一时刻只能有一台设备发送数据包，因此效率极为低下（HUB属于物理层，位于网络结构的最底层）

针对这个问题，SW/交换机出现了，它在HUB的基础上加入了不同机子的Mac地址和交换机物理端口的对应关系表，因此只要在数据包头部加入目标的Mac地址，SW就可以实现定向数据传输
，同时SW的连接线不同于双绞线，它能实现数据的双向传输，因此数据杂糅的问题也解决了（所以CSMA/CD协议被淘汰了）

SW中一开始并没有建立起本地设备们的Mac地址与端口的对应表，因此建立对应表的流程是：A向SW的1号口发送数据，SW检测到表中数据空白之后从所有端口发送数据，B收到数据之后向A返回数据，这个过程中SW就记录下了A和B的Mac地址与其端口的对应关系，长此以往它就能记录下所有对应关系（其中存在一个至关重要的ARP协议，SW通过这个协议获取目标IP对应的Mac地址，即A在未检测到B的IP对应Mac地址的情况下发出ARP数据包，通过SW进行全域广播，通过接收B返回的数据包记录B的IP与Mac的对应关系，在SW被基本淘汰的如今，其功能被集成到了路由器中）

SW传递的数据，其结构有两部分，即数据头和数据，数据头中记录了原机的原Mac地址与目标机的Mac地址，SW就是根据数据头中的地址将数据发给目标机的

SW之间可以进行桥接，所以多个机子可以对应同一个物理端口

SW的映射表能记录几千个数据，通过SW可以实现局域网内的高效率数据交流，但是如果将交流范围扩展到全球范围内这个数量显然远远不够（SW属于数据链路层，位于物理层之上）

针对该问题以及其他存在的问题，路由器出现了，又称网关，其用于不同局域网之间的机子的数据交流（路由器位于网络层）

路由器/DHCP服务器的出现伴随着IP地址的使用，Mac地址虽然独一无二，但考虑到移动计算机的存在以及为了网络系统的高效与灵活性（IP地址可以分层化，结构化地传递数据，只用Mac地址进行数据传输显然是不现实的，因为这意味着路由器得记住世界上或者辖区内每一台机子的Mac地址，这会导致其数据极为庞杂），IP地址作为全球网络系统的基础被发明出来了

IP地址分为网络号与主机号，如192.168.1.14这个IP地址，192.168.1是网络号，它代表了你所处的地区，14是你的主机号，它代表你在这个局域网中暂时的编号

在家庭的局域网使用情境下，首先是家庭的路由器会被网络运营商分配到一个IP地址，这是连接公网的IP地址，家庭局域网中的设备连接局域网时会向路由器发出IP地址的分配申请，路由器分配一个空余的DHCP地址给该设备，这时该设备就被分配到了一个完整的私有IP地址

私有IP地址属于内网范围，可以用于局域网内的不同机子的交流，如果想要访问公网的网站，则需要通过路由器，路由器接到数据包之后会把数据包的头中的私有IP改成该路由器所拥有的公有IP（这个过程是通过NAT，即网络地址转换技术实现的），然后发送给公网上的某网站服务器，服务器收到数据后将回复的数据根据路由器的公有IP发给路由器，路由器再次修改数据头的公有IP为原机的私有IP（同样是通过NAT实现），然后将数据发回到原机，这样就完成了一次数据交流

以上三层解决了不同地域间的数据交流问题，但没有解决传输数据包时的程序间区分的问题（即数据是发到QQ还是bilibili上），针对该问题，现在PC上每个应用程序都被分配了一个Port/端口，PC收到的数据会按数据包中提供的端口号提供到对应端口，再传给和端口连接的程序。而针对数据传输过程的速度，准确度与安全度，两种协议应运而生--即TCP与UDP协议，两者因其各自的特点被用于不同情景的数据传输中

TCP通过三次握手（主动方发送SYN包，被动方回复SYN-ACK包，主动方再回复ACK包）保证原机与目标机之间连接的可靠性，数据传输结束后通过四次挥手（主动方发送FIN包，被动方回复ACK包，被动方结束数据接收与处理之后回复FIN包，主动方回复ACK包）来断开连接

在传输数据的过程中，TCP规定了被传输的数据的每个字节都要有相应的顺序（序列号），同时双方会不断地确认接收情况（确认应答），如果被动方超过一段时间没有返回确认接收的数据包，主动方会认为数据在传输过程中丢包，于是重新传输这个未成功传输的数据（超时重传）

针对双方机器的数据接收和传输能力不一致的问题，TCP规定了滑动窗口机制，即接收方在每次发送 ACK 时，都会在包头中附带一个 ​​“窗口大小”​​ 字段，告诉发送方其当前还能接收多少字节的数据，而发送方根据接收方告知的窗口大小，动态调整自己能发送的数据范围。这个范围就像一个“窗口”，会随着 ACK 的到达而向右“滑动”，如果接收方处理不过来，可以把窗口大小设为 0，发送方就会暂停发送，直到接收方再次通告一个非零的窗口

针对网络环境可能对数据传输造成的影响，TCP规定了拥塞控制的机制，目的是为了防止网络本身被塞满的问题，TCP单独设置了一个拥塞窗口，通过不断地增加向其发送的字节数量来测试网络能供数据通行的通道大小是多少

而通过TCP实现的数据传输，其传输速度取决于接收窗口和拥塞窗口间更小的那一个

UDP协议则在大多数方面与TCP完全相反：不建立连接，不保证顺序，不考虑对方是否接收成功，不考虑对方的接收能力，不考虑网络是否拥塞，没有什么重传之类的机制，它最大的特点就是传输速度极快，常用于需要即时传递数据的场合

（TCP/UDP协议位于传输层）

子网掩码：以255.255.255.0为例，子网掩码用于向路由说明IP地址的哪部分是网络号，哪部分是主机号，同时也用于让路由判断该IP是位于局域网还是远程网
</pre>
    </div>

    <a href="javascript:history.back()" class="back-link">返回PPT</a>
</body>
</html>